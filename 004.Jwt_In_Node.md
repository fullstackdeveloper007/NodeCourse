**JWT (JSON Web Token) authentication in Node.js** 
---

## üîë What is JWT?

* **JWT (JSON Web Token)** is an open standard (RFC 7519) used for securely transmitting information between parties as a **JSON object**.
* It‚Äôs often used in authentication to verify **who the user is** and **what they‚Äôre allowed to do**.
* JWTs are **stateless** ‚Üí the server doesn‚Äôt need to store session data; all necessary info is inside the token.

---

## üß© Structure of a JWT

A JWT is made of **three parts**, separated by dots (`.`):

```
header.payload.signature
```

1. **Header**: Contains metadata (algorithm & token type).

   ```json
   { "alg": "HS256", "typ": "JWT" }
   ```

2. **Payload**: Contains user data (claims).

   ```json
   { "userId": 123, "role": "admin" }
   ```

3. **Signature**: Used to verify that the token is not altered.

   * Created using the header + payload + secret key.

Example JWT:

```
eyJhbGciOiJIUzI1NiIsInR5cCI6IkpXVCJ9.eyJ1c2VySWQiOjEyMywicm9sZSI6ImFkbWluIn0._abcdef12345
```

---

## ‚öôÔ∏è How JWT Authentication Works in Node.js

1. **User logs in** with username & password.
2. **Server validates credentials** and creates a JWT containing user info.
3. **JWT is sent to the client** (usually in response body or cookie).
4. **Client stores the JWT** (in `localStorage`, `sessionStorage`, or cookies).
5. For **every request to protected routes**, the client sends the JWT in the **Authorization header**:

   ```
   Authorization: Bearer <token>
   ```
6. **Server verifies the token** using the secret key:

   * If valid ‚Üí grant access.
   * If invalid/expired ‚Üí deny access.

---

## üöÄ Example: Implementing JWT in Node.js + Express

Install dependencies:

```bash
npm install express jsonwebtoken bcryptjs
```

### `server.js`

```javascript
const express = require('express');
const jwt = require('jsonwebtoken');
const bcrypt = require('bcryptjs');

const app = express();
app.use(express.json());

const users = []; // Dummy in-memory user store
const SECRET_KEY = "mysecretkey123";

// Register route
app.post('/register', async (req, res) => {
  const { username, password } = req.body;
  const hashedPassword = await bcrypt.hash(password, 10);
  users.push({ username, password: hashedPassword });
  res.json({ message: "User registered successfully" });
});

// Login route
app.post('/login', async (req, res) => {
  const { username, password } = req.body;
  const user = users.find(u => u.username === username);

  if (!user || !(await bcrypt.compare(password, user.password))) {
    return res.status(401).json({ message: "Invalid credentials" });
  }

  // Create JWT token
 //This will have three parts xxxxx.yyyyy.zzzzz (Header.Payload.Signature)
  const token = jwt.sign({ username }, SECRET_KEY, { expiresIn: "1h" });
  res.json({ token });
});

// Middleware to protect routes
function authenticateToken(req, res, next) {
  const authHeader = req.headers['authorization'];
  const token = authHeader && authHeader.split(' ')[1];

  if (!token) return res.sendStatus(401);

  jwt.verify(token, SECRET_KEY, (err, user) => {
    if (err) return res.sendStatus(403);
    req.user = user; // Attach user info to request
    next();
  });
}

// Protected route
app.get('/dashboard', authenticateToken, (req, res) => {
  res.json({ message: `Welcome ${req.user.username}! This is your dashboard.` });
});

app.listen(3000, () => console.log('Server running on http://localhost:3000'));
```

---

## ‚úÖ Best Practices

* Always use **HTTPS** so tokens aren‚Äôt exposed.
* Use **short expiry times** (`15m`, `1h`) and **refresh tokens** for long sessions.
* Store tokens **securely** (avoid `localStorage` if XSS risk is high ‚Üí prefer **HttpOnly cookies**).
* Rotate and invalidate tokens when necessary.

---

üëâ Would you like me to also explain **how Refresh Tokens work with JWT** (to handle long-lived sessions securely)?
