# **"How does JWT auth work in NestJS?"**, you can explain in steps:

1. **User Login / Signup**

   * The user provides credentials (email + password).
   * We validate the user against the database (using Prisma).
   * If valid, we **sign a JWT** (using `@nestjs/jwt`) with a secret and send it back to the client.

2. **Storing JWT on Client**

   * The client (browser, mobile app, Postman, etc.) stores this token (usually in localStorage, sessionStorage, or an HttpOnly cookie).

3. **Making Requests with JWT**

   * On every API call, the client attaches the token in the `Authorization: Bearer <token>` header.

4. **NestJS Validates the Token**

   * NestJS has a `JwtAuthGuard` (extending `AuthGuard('jwt')`) that checks for this token before the request hits the controller.
   * The guard verifies the token using the same secret key.
   * If valid, the payload (like `userId`) is attached to the `request.user`.

5. **Controller / Service Execution**

   * Since the request is authenticated, the controller can now safely query data (via Prisma) knowing which user is making the request.
   * If the token is invalid or missing, the guard throws `UnauthorizedException`.

---

### ğŸ”„ Flow (Step by Step)

1. **Login API â†’** Validate credentials â†’ Generate JWT â†’ Send to client.
2. **Client Stores Token â†’** In localStorage/cookie.
3. **Protected API Request â†’** Client sends JWT in headers.
4. **Guard â†’** Intercepts request, validates JWT, extracts payload.
5. **Controller â†’** Executes only if the guard passes.
6. **Service (Prisma) â†’** Executes queries based on `request.user`.

--- 

       â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚     Client    â”‚
       â”‚  (Browser /   â”‚
       â”‚   Postman)    â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   AuthController â”‚
       â”‚   /register      â”‚
       â”‚   /login         â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
  â”‚      AuthService       â”‚
  â”‚ - Hash password        â”‚
  â”‚ - Validate credentials â”‚
  â”‚ - Generate JWT token   â”‚
  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚   PrismaService â”‚
       â”‚ - Store user    â”‚
       â”‚ - Fetch user    â”‚
       â””â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              â”‚
       â”Œâ”€â”€â”€â”€â”€â”€â–¼â”€â”€â”€â”€â”€â”€â”€â”€â”
       â”‚    MS SQL DB   â”‚
       â”‚  Users table   â”‚
       â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
Perfect ğŸ‘ Iâ€™ll keep it **small and interview-ready** â€” enough to show you understand the flow.

Hereâ€™s a **minimal JWT auth setup with NestJS + Prisma + MS SQL**:

---

### 1. **auth.module.ts**

```ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { PrismaService } from '../prisma.service';

@Module({
  imports: [
    JwtModule.register({
      secret: 'mysecret123', // ğŸ”‘ keep in env
      signOptions: { expiresIn: '1h' },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, PrismaService],
})
export class AuthModule {}
```

---

### 2. **auth.service.ts**

```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(private prisma: PrismaService, private jwt: JwtService) {}

  async validateUser(email: string, pass: string) {
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (user && (await bcrypt.compare(pass, user.password))) {
      return user;
    }
    throw new UnauthorizedException('Invalid credentials');
  }

  async login(user: any) {
    const payload = { sub: user.id, email: user.email };
    return {
      access_token: this.jwt.sign(payload),
    };
  }
}
```

---

### 3. **auth.controller.ts**

```ts
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() body: { email: string; password: string }) {
    const user = await this.authService.validateUser(body.email, body.password);
    return this.authService.login(user);
  }
}
```

---

### 4. **jwt.strategy.ts**

```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: 'mysecret123', // ğŸ”‘ keep in env
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}
```

---

### 5. **protect an endpoint** (any controller)

```ts
import { Controller, Get, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller('profile')
export class ProfileController {
  @UseGuards(AuthGuard('jwt'))
  @Get()
  getProfile(@Request() req) {
    return req.user; // { userId, email }
  }
}
```

---

âœ… Now the flow is:

1. `POST /auth/login` â†’ returns JWT
2. `GET /profile` with `Authorization: Bearer <token>` â†’ returns user info

 
