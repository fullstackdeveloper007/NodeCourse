# **"How does JWT auth work in NestJS?"**, you can explain in steps:

1. **User Login / Signup**

   * The user provides credentials (email + password).
   * We validate the user against the database (using Prisma).
   * If valid, we **sign a JWT** (using `@nestjs/jwt`) with a secret and send it back to the client.

2. **Storing JWT on Client**

   * The client (browser, mobile app, Postman, etc.) stores this token (usually in localStorage, sessionStorage, or an HttpOnly cookie).

3. **Making Requests with JWT**

   * On every API call, the client attaches the token in the `Authorization: Bearer <token>` header.

4. **NestJS Validates the Token**

   * NestJS has a `JwtAuthGuard` (extending `AuthGuard('jwt')`) that checks for this token before the request hits the controller.
   * The guard verifies the token using the same secret key.
   * If valid, the payload (like `userId`) is attached to the `request.user`.

5. **Controller / Service Execution**

   * Since the request is authenticated, the controller can now safely query data (via Prisma) knowing which user is making the request.
   * If the token is invalid or missing, the guard throws `UnauthorizedException`.

---

### 🔄 Flow (Step by Step)

1. **Login API →** Validate credentials → Generate JWT → Send to client.
2. **Client Stores Token →** In localStorage/cookie.
3. **Protected API Request →** Client sends JWT in headers.
4. **Guard →** Intercepts request, validates JWT, extracts payload.
5. **Controller →** Executes only if the guard passes.
6. **Service (Prisma) →** Executes queries based on `request.user`.

--- 

       ┌───────────────┐
       │     Client    │
       │  (Browser /   │
       │   Postman)    │
       └──────┬────────┘
              │
       ┌──────▼────────┐
       │   AuthController │
       │   /register      │
       │   /login         │
       └──────┬────────┘
              │
  ┌───────────▼───────────┐
  │      AuthService       │
  │ - Hash password        │
  │ - Validate credentials │
  │ - Generate JWT token   │
  └───────────┬───────────┘
              │
       ┌──────▼────────┐
       │   PrismaService │
       │ - Store user    │
       │ - Fetch user    │
       └──────┬────────┘
              │
       ┌──────▼────────┐
       │    MS SQL DB   │
       │  Users table   │
       └───────────────┘
Perfect 👍 I’ll keep it **small and interview-ready** — enough to show you understand the flow.

Here’s a **minimal JWT auth setup with NestJS + Prisma + MS SQL**:

---

### 1. **auth.module.ts**

```ts
import { Module } from '@nestjs/common';
import { JwtModule } from '@nestjs/jwt';
import { AuthService } from './auth.service';
import { AuthController } from './auth.controller';
import { JwtStrategy } from './jwt.strategy';
import { PrismaService } from '../prisma.service';

@Module({
  imports: [
    JwtModule.register({
      secret: 'mysecret123', // 🔑 keep in env
      signOptions: { expiresIn: '1h' },
    }),
  ],
  controllers: [AuthController],
  providers: [AuthService, JwtStrategy, PrismaService],
})
export class AuthModule {}
```

---

### 2. **auth.service.ts**

```ts
import { Injectable, UnauthorizedException } from '@nestjs/common';
import { JwtService } from '@nestjs/jwt';
import { PrismaService } from '../prisma.service';
import * as bcrypt from 'bcrypt';

@Injectable()
export class AuthService {
  constructor(private prisma: PrismaService, private jwt: JwtService) {}

  async validateUser(email: string, pass: string) {
    const user = await this.prisma.user.findUnique({ where: { email } });
    if (user && (await bcrypt.compare(pass, user.password))) {
      return user;
    }
    throw new UnauthorizedException('Invalid credentials');
  }

  async login(user: any) {
    const payload = { sub: user.id, email: user.email };
    return {
      access_token: this.jwt.sign(payload),
    };
  }
}
```

---

### 3. **auth.controller.ts**

```ts
import { Controller, Post, Body } from '@nestjs/common';
import { AuthService } from './auth.service';

@Controller('auth')
export class AuthController {
  constructor(private authService: AuthService) {}

  @Post('login')
  async login(@Body() body: { email: string; password: string }) {
    const user = await this.authService.validateUser(body.email, body.password);
    return this.authService.login(user);
  }
}
```

---

### 4. **jwt.strategy.ts**

```ts
import { Injectable } from '@nestjs/common';
import { PassportStrategy } from '@nestjs/passport';
import { ExtractJwt, Strategy } from 'passport-jwt';

@Injectable()
export class JwtStrategy extends PassportStrategy(Strategy) {
  constructor() {
    super({
      jwtFromRequest: ExtractJwt.fromAuthHeaderAsBearerToken(),
      secretOrKey: 'mysecret123', // 🔑 keep in env
    });
  }

  async validate(payload: any) {
    return { userId: payload.sub, email: payload.email };
  }
}
```

---

### 5. **protect an endpoint** (any controller)

```ts
import { Controller, Get, UseGuards, Request } from '@nestjs/common';
import { AuthGuard } from '@nestjs/passport';

@Controller('profile')
export class ProfileController {
  @UseGuards(AuthGuard('jwt'))
  @Get()
  getProfile(@Request() req) {
    return req.user; // { userId, email }
  }
}
```

---

✅ Now the flow is:

1. `POST /auth/login` → returns JWT
2. `GET /profile` with `Authorization: Bearer <token>` → returns user info

 
